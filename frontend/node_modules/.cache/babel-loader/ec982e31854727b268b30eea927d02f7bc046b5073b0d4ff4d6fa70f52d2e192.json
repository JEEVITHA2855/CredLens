{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000,\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  },\n  withCredentials: true\n});\nexport const analyzeClaimAPI = async input => {\n  try {\n    console.log('Sending analysis request:', input);\n    const response = await api.post('/analyze', {\n      text: input.text\n    });\n    console.log('Received response:', response.data);\n\n    // If the response already has the expected structure, return it as-is\n    if (response.data && response.data.claim) {\n      return response.data;\n    }\n\n    // Otherwise, map ultra_simple backend response to the UI-expected schema\n    const data = response.data || {};\n    const claimText = data.claim_text || (input === null || input === void 0 ? void 0 : input.text) || (input === null || input === void 0 ? void 0 : input.url) || '';\n    if (!claimText) {\n      throw new Error('Invalid response format');\n    }\n\n    // Helper: quick URL check\n    const isUrl = val => {\n      try {\n        new URL(val);\n        return true;\n      } catch (_) {\n        return false;\n      }\n    };\n\n    // Map backend status to UI verification status labels\n    const statusMap = {\n      VERIFIED: 'Likely True',\n      DEBUNKED: 'Likely False',\n      UNCERTAIN: 'Mixed'\n    };\n    let uiVerificationStatus = statusMap[data.status] || 'Mixed';\n\n    // Normalize evidence into the richer structure expected by the UI\n    const flatEvidence = Array.isArray(data.evidence) ? data.evidence : [];\n    const confidenceScore = typeof data.confidence_score === 'number' ? data.confidence_score : 0.5; // 0..1\n\n    const mappedEvidence = flatEvidence.map(item => {\n      // If item is a simple string, convert to structured record\n      if (typeof item === 'string') {\n        if (isUrl(item)) {\n          let host = '';\n          try {\n            host = new URL(item).hostname;\n          } catch (_) {\n            host = 'Source';\n          }\n          return {\n            text: 'Referenced source',\n            source: host,\n            url: item,\n            nli_label: 'ENTAILMENT',\n            confidence: confidenceScore,\n            similarity_score: Math.min(1, Math.max(0, confidenceScore))\n          };\n        }\n        return {\n          text: item,\n          source: 'AI Analysis',\n          nli_label: 'NEUTRAL',\n          confidence: 0.6,\n          similarity_score: 0.5\n        };\n      }\n      // If already an object, ensure required fields with sensible defaults\n      return {\n        text: item.text || 'Evidence',\n        source: item.source || 'AI Analysis',\n        url: item.url || undefined,\n        nli_label: item.nli_label || 'NEUTRAL',\n        confidence: typeof item.confidence === 'number' ? item.confidence : confidenceScore,\n        similarity_score: typeof item.similarity_score === 'number' ? item.similarity_score : 0.5\n      };\n    });\n\n    // Use backend-provided fingerprint if available; otherwise synthesize a basic one\n    let fingerprint = data.credibility_fingerprint;\n    if (!fingerprint || typeof fingerprint !== 'object') {\n      const corroborationCount = mappedEvidence.filter(e => !!e.url).length;\n      const overall = Math.min(1, Math.max(0, confidenceScore));\n      fingerprint = {\n        overall_score: overall,\n        source_credibility: overall,\n        // reuse confidence as a proxy\n        language_risk: Math.max(0, 1 - overall),\n        corroboration_count: corroborationCount\n      };\n    }\n    if ((mappedEvidence.length === 0 || mappedEvidence.every(e => !e.url)) && (fingerprint.overall_score || 0) < 0.45) {\n      uiVerificationStatus = 'Unverified';\n    }\n\n    // Provide a simple micro-lesson tip\n    let microLesson = data.micro_lesson || 'Always verify information across multiple reliable sources.';\n    if (!data.micro_lesson) {\n      if (uiVerificationStatus === 'Likely True') {\n        microLesson = 'Corroborate with at least two independent, reputable sources.';\n      } else if (uiVerificationStatus === 'Likely False') {\n        microLesson = 'Be wary of sensational claims—check reputable fact-checkers and primary sources.';\n      } else {\n        microLesson = 'Seek more reliable sources and check dates, authors, and original context.';\n      }\n    }\n\n    // Build detective-style reasons\n    const reasons = Array.isArray(data.reasons) && data.reasons.length > 0 ? data.reasons.slice(0, 3) : function () {\n      const r = [];\n      const hasUrls = mappedEvidence.some(e => !!e.url);\n      if (!hasUrls) r.push('Limited corroboration found; verify with additional sources.');\n      if (Array.isArray(data.suspicious_phrases) && data.suspicious_phrases.length > 0) {\n        const phrases = data.suspicious_phrases.slice(0, 2).map(p => p.phrase).join(', ');\n        r.push(`Language uses emotional or clickbait terms (${phrases}).`);\n      }\n      if (isUrl((input === null || input === void 0 ? void 0 : input.text) || '')) {\n        try {\n          const domain = new URL(input.text).hostname;\n          r.push(`Source domain: ${domain}`);\n        } catch {}\n      }\n      return r.slice(0, 3);\n    }();\n    const mapped = {\n      // Core fields expected by App and components\n      claim: claimText,\n      extracted_claim: claimText,\n      original_input: (input === null || input === void 0 ? void 0 : input.text) || (input === null || input === void 0 ? void 0 : input.url) || claimText,\n      credibility_fingerprint: fingerprint,\n      evidence: mappedEvidence,\n      verification_status: uiVerificationStatus,\n      suspicious_phrases: Array.isArray(data.suspicious_phrases) ? data.suspicious_phrases : [],\n      micro_lesson: microLesson,\n      explanation: data.explanation || 'Analysis completed using Gemini AI',\n      reasons,\n      metadata: data.metadata || {}\n    };\n    return mapped;\n  } catch (error) {\n    console.error('Analysis error:', error);\n\n    // Detailed error logging\n    if (error.response) {\n      var _error$response$data;\n      console.error('Response error:', error.response.data);\n      throw new Error(((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Server error: ' + error.response.status);\n    } else if (error.request) {\n      console.error('Request error:', error.request);\n      throw new Error('Cannot connect to server - please check if the backend is running');\n    } else {\n      console.error('Other error:', error.message);\n      throw new Error(error.message || 'An unexpected error occurred');\n    }\n  }\n};\nexport const analyzeIndustrialAPI = async content => {\n  try {\n    const response = await api.post('/analyze-industrial', {\n      content\n    });\n    return response.data;\n  } catch (error) {\n    if (error.response) {\n      throw new Error(error.response.data.detail || 'Industrial analysis failed');\n    } else if (error.request) {\n      throw new Error('Network error - please check your connection');\n    } else {\n      throw new Error('Request failed - please try again');\n    }\n  }\n};\nexport const getHealthAPI = async () => {\n  try {\n    const response = await api.get('/health');\n    return response.data;\n  } catch (error) {\n    throw new Error('Health check failed');\n  }\n};\nexport const getStatsAPI = async () => {\n  try {\n    const response = await api.get('/stats');\n    return response.data;\n  } catch (error) {\n    throw new Error('Stats fetch failed');\n  }\n};\nexport default api;","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_URL","api","create","baseURL","timeout","headers","withCredentials","analyzeClaimAPI","input","console","log","response","post","text","data","claim","claimText","claim_text","url","Error","isUrl","val","URL","_","statusMap","VERIFIED","DEBUNKED","UNCERTAIN","uiVerificationStatus","status","flatEvidence","Array","isArray","evidence","confidenceScore","confidence_score","mappedEvidence","map","item","host","hostname","source","nli_label","confidence","similarity_score","Math","min","max","undefined","fingerprint","credibility_fingerprint","corroborationCount","filter","e","length","overall","overall_score","source_credibility","language_risk","corroboration_count","every","microLesson","micro_lesson","reasons","slice","r","hasUrls","some","push","suspicious_phrases","phrases","p","phrase","join","domain","mapped","extracted_claim","original_input","verification_status","explanation","metadata","error","_error$response$data","request","message","analyzeIndustrialAPI","content","detail","getHealthAPI","get","getStatsAPI"],"sources":["E:/CredLens/frontend/src/utils/api.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\r\n\r\nconst api = axios.create({\r\n  baseURL: API_BASE_URL,\r\n  timeout: 30000,\r\n  headers: {\r\n    'Content-Type': 'application/json',\r\n    'Accept': 'application/json'\r\n  },\r\n  withCredentials: true\r\n});\r\n\r\nexport const analyzeClaimAPI = async (input) => {\r\n  try {\r\n    console.log('Sending analysis request:', input);\r\n    const response = await api.post('/analyze', { text: input.text });\r\n    console.log('Received response:', response.data);\r\n    \r\n    // If the response already has the expected structure, return it as-is\r\n    if (response.data && response.data.claim) {\r\n      return response.data;\r\n    }\r\n\r\n    // Otherwise, map ultra_simple backend response to the UI-expected schema\r\n    const data = response.data || {};\r\n\r\n    const claimText = data.claim_text || input?.text || input?.url || '';\r\n    if (!claimText) {\r\n      throw new Error('Invalid response format');\r\n    }\r\n\r\n    // Helper: quick URL check\r\n    const isUrl = (val) => {\r\n      try { new URL(val); return true; } catch (_) { return false; }\r\n    };\r\n\r\n    // Map backend status to UI verification status labels\r\n    const statusMap = {\r\n      VERIFIED: 'Likely True',\r\n      DEBUNKED: 'Likely False',\r\n      UNCERTAIN: 'Mixed',\r\n    };\r\n  let uiVerificationStatus = statusMap[data.status] || 'Mixed';\r\n\r\n    // Normalize evidence into the richer structure expected by the UI\r\n    const flatEvidence = Array.isArray(data.evidence) ? data.evidence : [];\r\n    const confidenceScore = typeof data.confidence_score === 'number' ? data.confidence_score : 0.5; // 0..1\r\n\r\n    const mappedEvidence = flatEvidence.map((item) => {\r\n      // If item is a simple string, convert to structured record\r\n      if (typeof item === 'string') {\r\n        if (isUrl(item)) {\r\n          let host = '';\r\n          try { host = new URL(item).hostname; } catch (_) { host = 'Source'; }\r\n          return {\r\n            text: 'Referenced source',\r\n            source: host,\r\n            url: item,\r\n            nli_label: 'ENTAILMENT',\r\n            confidence: confidenceScore,\r\n            similarity_score: Math.min(1, Math.max(0, confidenceScore)),\r\n          };\r\n        }\r\n        return {\r\n          text: item,\r\n          source: 'AI Analysis',\r\n          nli_label: 'NEUTRAL',\r\n          confidence: 0.6,\r\n          similarity_score: 0.5,\r\n        };\r\n      }\r\n      // If already an object, ensure required fields with sensible defaults\r\n      return {\r\n        text: item.text || 'Evidence',\r\n        source: item.source || 'AI Analysis',\r\n        url: item.url || undefined,\r\n        nli_label: item.nli_label || 'NEUTRAL',\r\n        confidence: typeof item.confidence === 'number' ? item.confidence : confidenceScore,\r\n        similarity_score: typeof item.similarity_score === 'number' ? item.similarity_score : 0.5,\r\n      };\r\n    });\r\n\r\n  // Use backend-provided fingerprint if available; otherwise synthesize a basic one\r\n    let fingerprint = data.credibility_fingerprint;\r\n    if (!fingerprint || typeof fingerprint !== 'object') {\r\n      const corroborationCount = mappedEvidence.filter(e => !!e.url).length;\r\n      const overall = Math.min(1, Math.max(0, confidenceScore));\r\n      fingerprint = {\r\n        overall_score: overall,\r\n        source_credibility: overall, // reuse confidence as a proxy\r\n        language_risk: Math.max(0, 1 - overall),\r\n        corroboration_count: corroborationCount,\r\n      };\r\n    }\r\n\r\n    if ((mappedEvidence.length === 0 || mappedEvidence.every(e => !e.url)) && (fingerprint.overall_score || 0) < 0.45) {\r\n      uiVerificationStatus = 'Unverified';\r\n    }\r\n\r\n    // Provide a simple micro-lesson tip\r\n    let microLesson = data.micro_lesson || 'Always verify information across multiple reliable sources.';\r\n    if (!data.micro_lesson) {\r\n      if (uiVerificationStatus === 'Likely True') {\r\n        microLesson = 'Corroborate with at least two independent, reputable sources.';\r\n      } else if (uiVerificationStatus === 'Likely False') {\r\n        microLesson = 'Be wary of sensational claims—check reputable fact-checkers and primary sources.';\r\n      } else {\r\n        microLesson = 'Seek more reliable sources and check dates, authors, and original context.';\r\n      }\r\n    }\r\n\r\n    // Build detective-style reasons\r\n    const reasons = Array.isArray(data.reasons) && data.reasons.length > 0\r\n      ? data.reasons.slice(0, 3)\r\n      : (function() {\r\n          const r = [];\r\n          const hasUrls = mappedEvidence.some(e => !!e.url);\r\n          if (!hasUrls) r.push('Limited corroboration found; verify with additional sources.');\r\n          if (Array.isArray(data.suspicious_phrases) && data.suspicious_phrases.length > 0) {\r\n            const phrases = data.suspicious_phrases.slice(0,2).map(p => p.phrase).join(', ');\r\n            r.push(`Language uses emotional or clickbait terms (${phrases}).`);\r\n          }\r\n          if (isUrl(input?.text || '')) {\r\n            try {\r\n              const domain = new URL(input.text).hostname;\r\n              r.push(`Source domain: ${domain}`);\r\n            } catch {}\r\n          }\r\n          return r.slice(0,3);\r\n        })();\r\n\r\n    const mapped = {\r\n      // Core fields expected by App and components\r\n      claim: claimText,\r\n      extracted_claim: claimText,\r\n      original_input: input?.text || input?.url || claimText,\r\n      credibility_fingerprint: fingerprint,\r\n      evidence: mappedEvidence,\r\n      verification_status: uiVerificationStatus,\r\n  suspicious_phrases: Array.isArray(data.suspicious_phrases) ? data.suspicious_phrases : [],\r\n      micro_lesson: microLesson,\r\n      explanation: data.explanation || 'Analysis completed using Gemini AI',\r\n      reasons,\r\n      metadata: data.metadata || {},\r\n    };\r\n\r\n    return mapped;\r\n  } catch (error) {\r\n    console.error('Analysis error:', error);\r\n    \r\n    // Detailed error logging\r\n    if (error.response) {\r\n      console.error('Response error:', error.response.data);\r\n      throw new Error(error.response.data?.error || 'Server error: ' + error.response.status);\r\n    } else if (error.request) {\r\n      console.error('Request error:', error.request);\r\n      throw new Error('Cannot connect to server - please check if the backend is running');\r\n    } else {\r\n      console.error('Other error:', error.message);\r\n      throw new Error(error.message || 'An unexpected error occurred');\r\n    }\r\n  }\r\n};\r\n\r\nexport const analyzeIndustrialAPI = async (content) => {\r\n  try {\r\n    const response = await api.post('/analyze-industrial', { content });\r\n    return response.data;\r\n  } catch (error) {\r\n    if (error.response) {\r\n      throw new Error(error.response.data.detail || 'Industrial analysis failed');\r\n    } else if (error.request) {\r\n      throw new Error('Network error - please check your connection');\r\n    } else {\r\n      throw new Error('Request failed - please try again');\r\n    }\r\n  }\r\n};\r\n\r\nexport const getHealthAPI = async () => {\r\n  try {\r\n    const response = await api.get('/health');\r\n    return response.data;\r\n  } catch (error) {\r\n    throw new Error('Health check failed');\r\n  }\r\n};\r\n\r\nexport const getStatsAPI = async () => {\r\n  try {\r\n    const response = await api.get('/stats');\r\n    return response.data;\r\n  } catch (error) {\r\n    throw new Error('Stats fetch failed');\r\n  }\r\n};\r\n\r\nexport default api;"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,MAAMC,YAAY,GAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,IAAI,uBAAuB;AAE7E,MAAMC,GAAG,GAAGL,KAAK,CAACM,MAAM,CAAC;EACvBC,OAAO,EAAEN,YAAY;EACrBO,OAAO,EAAE,KAAK;EACdC,OAAO,EAAE;IACP,cAAc,EAAE,kBAAkB;IAClC,QAAQ,EAAE;EACZ,CAAC;EACDC,eAAe,EAAE;AACnB,CAAC,CAAC;AAEF,OAAO,MAAMC,eAAe,GAAG,MAAOC,KAAK,IAAK;EAC9C,IAAI;IACFC,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEF,KAAK,CAAC;IAC/C,MAAMG,QAAQ,GAAG,MAAMV,GAAG,CAACW,IAAI,CAAC,UAAU,EAAE;MAAEC,IAAI,EAAEL,KAAK,CAACK;IAAK,CAAC,CAAC;IACjEJ,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEC,QAAQ,CAACG,IAAI,CAAC;;IAEhD;IACA,IAAIH,QAAQ,CAACG,IAAI,IAAIH,QAAQ,CAACG,IAAI,CAACC,KAAK,EAAE;MACxC,OAAOJ,QAAQ,CAACG,IAAI;IACtB;;IAEA;IACA,MAAMA,IAAI,GAAGH,QAAQ,CAACG,IAAI,IAAI,CAAC,CAAC;IAEhC,MAAME,SAAS,GAAGF,IAAI,CAACG,UAAU,KAAIT,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEK,IAAI,MAAIL,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEU,GAAG,KAAI,EAAE;IACpE,IAAI,CAACF,SAAS,EAAE;MACd,MAAM,IAAIG,KAAK,CAAC,yBAAyB,CAAC;IAC5C;;IAEA;IACA,MAAMC,KAAK,GAAIC,GAAG,IAAK;MACrB,IAAI;QAAE,IAAIC,GAAG,CAACD,GAAG,CAAC;QAAE,OAAO,IAAI;MAAE,CAAC,CAAC,OAAOE,CAAC,EAAE;QAAE,OAAO,KAAK;MAAE;IAC/D,CAAC;;IAED;IACA,MAAMC,SAAS,GAAG;MAChBC,QAAQ,EAAE,aAAa;MACvBC,QAAQ,EAAE,cAAc;MACxBC,SAAS,EAAE;IACb,CAAC;IACH,IAAIC,oBAAoB,GAAGJ,SAAS,CAACV,IAAI,CAACe,MAAM,CAAC,IAAI,OAAO;;IAE1D;IACA,MAAMC,YAAY,GAAGC,KAAK,CAACC,OAAO,CAAClB,IAAI,CAACmB,QAAQ,CAAC,GAAGnB,IAAI,CAACmB,QAAQ,GAAG,EAAE;IACtE,MAAMC,eAAe,GAAG,OAAOpB,IAAI,CAACqB,gBAAgB,KAAK,QAAQ,GAAGrB,IAAI,CAACqB,gBAAgB,GAAG,GAAG,CAAC,CAAC;;IAEjG,MAAMC,cAAc,GAAGN,YAAY,CAACO,GAAG,CAAEC,IAAI,IAAK;MAChD;MACA,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;QAC5B,IAAIlB,KAAK,CAACkB,IAAI,CAAC,EAAE;UACf,IAAIC,IAAI,GAAG,EAAE;UACb,IAAI;YAAEA,IAAI,GAAG,IAAIjB,GAAG,CAACgB,IAAI,CAAC,CAACE,QAAQ;UAAE,CAAC,CAAC,OAAOjB,CAAC,EAAE;YAAEgB,IAAI,GAAG,QAAQ;UAAE;UACpE,OAAO;YACL1B,IAAI,EAAE,mBAAmB;YACzB4B,MAAM,EAAEF,IAAI;YACZrB,GAAG,EAAEoB,IAAI;YACTI,SAAS,EAAE,YAAY;YACvBC,UAAU,EAAET,eAAe;YAC3BU,gBAAgB,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEb,eAAe,CAAC;UAC5D,CAAC;QACH;QACA,OAAO;UACLrB,IAAI,EAAEyB,IAAI;UACVG,MAAM,EAAE,aAAa;UACrBC,SAAS,EAAE,SAAS;UACpBC,UAAU,EAAE,GAAG;UACfC,gBAAgB,EAAE;QACpB,CAAC;MACH;MACA;MACA,OAAO;QACL/B,IAAI,EAAEyB,IAAI,CAACzB,IAAI,IAAI,UAAU;QAC7B4B,MAAM,EAAEH,IAAI,CAACG,MAAM,IAAI,aAAa;QACpCvB,GAAG,EAAEoB,IAAI,CAACpB,GAAG,IAAI8B,SAAS;QAC1BN,SAAS,EAAEJ,IAAI,CAACI,SAAS,IAAI,SAAS;QACtCC,UAAU,EAAE,OAAOL,IAAI,CAACK,UAAU,KAAK,QAAQ,GAAGL,IAAI,CAACK,UAAU,GAAGT,eAAe;QACnFU,gBAAgB,EAAE,OAAON,IAAI,CAACM,gBAAgB,KAAK,QAAQ,GAAGN,IAAI,CAACM,gBAAgB,GAAG;MACxF,CAAC;IACH,CAAC,CAAC;;IAEJ;IACE,IAAIK,WAAW,GAAGnC,IAAI,CAACoC,uBAAuB;IAC9C,IAAI,CAACD,WAAW,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE;MACnD,MAAME,kBAAkB,GAAGf,cAAc,CAACgB,MAAM,CAACC,CAAC,IAAI,CAAC,CAACA,CAAC,CAACnC,GAAG,CAAC,CAACoC,MAAM;MACrE,MAAMC,OAAO,GAAGV,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEb,eAAe,CAAC,CAAC;MACzDe,WAAW,GAAG;QACZO,aAAa,EAAED,OAAO;QACtBE,kBAAkB,EAAEF,OAAO;QAAE;QAC7BG,aAAa,EAAEb,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE,CAAC,GAAGQ,OAAO,CAAC;QACvCI,mBAAmB,EAAER;MACvB,CAAC;IACH;IAEA,IAAI,CAACf,cAAc,CAACkB,MAAM,KAAK,CAAC,IAAIlB,cAAc,CAACwB,KAAK,CAACP,CAAC,IAAI,CAACA,CAAC,CAACnC,GAAG,CAAC,KAAK,CAAC+B,WAAW,CAACO,aAAa,IAAI,CAAC,IAAI,IAAI,EAAE;MACjH5B,oBAAoB,GAAG,YAAY;IACrC;;IAEA;IACA,IAAIiC,WAAW,GAAG/C,IAAI,CAACgD,YAAY,IAAI,6DAA6D;IACpG,IAAI,CAAChD,IAAI,CAACgD,YAAY,EAAE;MACtB,IAAIlC,oBAAoB,KAAK,aAAa,EAAE;QAC1CiC,WAAW,GAAG,+DAA+D;MAC/E,CAAC,MAAM,IAAIjC,oBAAoB,KAAK,cAAc,EAAE;QAClDiC,WAAW,GAAG,kFAAkF;MAClG,CAAC,MAAM;QACLA,WAAW,GAAG,4EAA4E;MAC5F;IACF;;IAEA;IACA,MAAME,OAAO,GAAGhC,KAAK,CAACC,OAAO,CAAClB,IAAI,CAACiD,OAAO,CAAC,IAAIjD,IAAI,CAACiD,OAAO,CAACT,MAAM,GAAG,CAAC,GAClExC,IAAI,CAACiD,OAAO,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,GACvB,YAAW;MACV,MAAMC,CAAC,GAAG,EAAE;MACZ,MAAMC,OAAO,GAAG9B,cAAc,CAAC+B,IAAI,CAACd,CAAC,IAAI,CAAC,CAACA,CAAC,CAACnC,GAAG,CAAC;MACjD,IAAI,CAACgD,OAAO,EAAED,CAAC,CAACG,IAAI,CAAC,8DAA8D,CAAC;MACpF,IAAIrC,KAAK,CAACC,OAAO,CAAClB,IAAI,CAACuD,kBAAkB,CAAC,IAAIvD,IAAI,CAACuD,kBAAkB,CAACf,MAAM,GAAG,CAAC,EAAE;QAChF,MAAMgB,OAAO,GAAGxD,IAAI,CAACuD,kBAAkB,CAACL,KAAK,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC3B,GAAG,CAACkC,CAAC,IAAIA,CAAC,CAACC,MAAM,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;QAChFR,CAAC,CAACG,IAAI,CAAC,+CAA+CE,OAAO,IAAI,CAAC;MACpE;MACA,IAAIlD,KAAK,CAAC,CAAAZ,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEK,IAAI,KAAI,EAAE,CAAC,EAAE;QAC5B,IAAI;UACF,MAAM6D,MAAM,GAAG,IAAIpD,GAAG,CAACd,KAAK,CAACK,IAAI,CAAC,CAAC2B,QAAQ;UAC3CyB,CAAC,CAACG,IAAI,CAAC,kBAAkBM,MAAM,EAAE,CAAC;QACpC,CAAC,CAAC,MAAM,CAAC;MACX;MACA,OAAOT,CAAC,CAACD,KAAK,CAAC,CAAC,EAAC,CAAC,CAAC;IACrB,CAAC,CAAE,CAAC;IAER,MAAMW,MAAM,GAAG;MACb;MACA5D,KAAK,EAAEC,SAAS;MAChB4D,eAAe,EAAE5D,SAAS;MAC1B6D,cAAc,EAAE,CAAArE,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEK,IAAI,MAAIL,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEU,GAAG,KAAIF,SAAS;MACtDkC,uBAAuB,EAAED,WAAW;MACpChB,QAAQ,EAAEG,cAAc;MACxB0C,mBAAmB,EAAElD,oBAAoB;MAC7CyC,kBAAkB,EAAEtC,KAAK,CAACC,OAAO,CAAClB,IAAI,CAACuD,kBAAkB,CAAC,GAAGvD,IAAI,CAACuD,kBAAkB,GAAG,EAAE;MACrFP,YAAY,EAAED,WAAW;MACzBkB,WAAW,EAAEjE,IAAI,CAACiE,WAAW,IAAI,oCAAoC;MACrEhB,OAAO;MACPiB,QAAQ,EAAElE,IAAI,CAACkE,QAAQ,IAAI,CAAC;IAC9B,CAAC;IAED,OAAOL,MAAM;EACf,CAAC,CAAC,OAAOM,KAAK,EAAE;IACdxE,OAAO,CAACwE,KAAK,CAAC,iBAAiB,EAAEA,KAAK,CAAC;;IAEvC;IACA,IAAIA,KAAK,CAACtE,QAAQ,EAAE;MAAA,IAAAuE,oBAAA;MAClBzE,OAAO,CAACwE,KAAK,CAAC,iBAAiB,EAAEA,KAAK,CAACtE,QAAQ,CAACG,IAAI,CAAC;MACrD,MAAM,IAAIK,KAAK,CAAC,EAAA+D,oBAAA,GAAAD,KAAK,CAACtE,QAAQ,CAACG,IAAI,cAAAoE,oBAAA,uBAAnBA,oBAAA,CAAqBD,KAAK,KAAI,gBAAgB,GAAGA,KAAK,CAACtE,QAAQ,CAACkB,MAAM,CAAC;IACzF,CAAC,MAAM,IAAIoD,KAAK,CAACE,OAAO,EAAE;MACxB1E,OAAO,CAACwE,KAAK,CAAC,gBAAgB,EAAEA,KAAK,CAACE,OAAO,CAAC;MAC9C,MAAM,IAAIhE,KAAK,CAAC,mEAAmE,CAAC;IACtF,CAAC,MAAM;MACLV,OAAO,CAACwE,KAAK,CAAC,cAAc,EAAEA,KAAK,CAACG,OAAO,CAAC;MAC5C,MAAM,IAAIjE,KAAK,CAAC8D,KAAK,CAACG,OAAO,IAAI,8BAA8B,CAAC;IAClE;EACF;AACF,CAAC;AAED,OAAO,MAAMC,oBAAoB,GAAG,MAAOC,OAAO,IAAK;EACrD,IAAI;IACF,MAAM3E,QAAQ,GAAG,MAAMV,GAAG,CAACW,IAAI,CAAC,qBAAqB,EAAE;MAAE0E;IAAQ,CAAC,CAAC;IACnE,OAAO3E,QAAQ,CAACG,IAAI;EACtB,CAAC,CAAC,OAAOmE,KAAK,EAAE;IACd,IAAIA,KAAK,CAACtE,QAAQ,EAAE;MAClB,MAAM,IAAIQ,KAAK,CAAC8D,KAAK,CAACtE,QAAQ,CAACG,IAAI,CAACyE,MAAM,IAAI,4BAA4B,CAAC;IAC7E,CAAC,MAAM,IAAIN,KAAK,CAACE,OAAO,EAAE;MACxB,MAAM,IAAIhE,KAAK,CAAC,8CAA8C,CAAC;IACjE,CAAC,MAAM;MACL,MAAM,IAAIA,KAAK,CAAC,mCAAmC,CAAC;IACtD;EACF;AACF,CAAC;AAED,OAAO,MAAMqE,YAAY,GAAG,MAAAA,CAAA,KAAY;EACtC,IAAI;IACF,MAAM7E,QAAQ,GAAG,MAAMV,GAAG,CAACwF,GAAG,CAAC,SAAS,CAAC;IACzC,OAAO9E,QAAQ,CAACG,IAAI;EACtB,CAAC,CAAC,OAAOmE,KAAK,EAAE;IACd,MAAM,IAAI9D,KAAK,CAAC,qBAAqB,CAAC;EACxC;AACF,CAAC;AAED,OAAO,MAAMuE,WAAW,GAAG,MAAAA,CAAA,KAAY;EACrC,IAAI;IACF,MAAM/E,QAAQ,GAAG,MAAMV,GAAG,CAACwF,GAAG,CAAC,QAAQ,CAAC;IACxC,OAAO9E,QAAQ,CAACG,IAAI;EACtB,CAAC,CAAC,OAAOmE,KAAK,EAAE;IACd,MAAM,IAAI9D,KAAK,CAAC,oBAAoB,CAAC;EACvC;AACF,CAAC;AAED,eAAelB,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}